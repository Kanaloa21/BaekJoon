# 1003

## 피보나치 함수

## 다이나믹 프로그래밍

[1003번: 피보나치 함수](https://www.acmicpc.net/problem/1003)

문제에서 보여주는 피보나치 수열 계산 함수를 사용하면 매우 비효율적이다! 무수한 TimeOut의 세례는 덤

보통 [피보나치 수열](https://ko.wikipedia.org/wiki/%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98_%EC%88%98%EC%97%B4)을 구하는 함수는
재귀함수의 반복으로 작은 문제로 쪼개는것까지는 가능하지만,   
이미 해결한 작은 문제를 또 푸는 것이 성능저하의 요인이 되고 그대로 코드를 제출하면 
필히, 시간초과 메시지를 보게 될 것이다.

> (출처: 위키백과, 동적 계획법)
> 
> 
> 보통 [피보나치 수열](https://ko.wikipedia.org/wiki/%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98_%EC%88%98%EC%97%B4)을 구하는 함수는 다음과 같이 작성한다.
> 
> ```
> function fib(n)
>  if n = 0
>   return 0
>  else if n=1
>   return 1
>  else
>   return fib(n-1) + fib(n-2)
> ```
> 
> 이때, fib(5)를 구한다고 한다면 계산은 다음과 같이 이루어진다.
> 
> 1. `fib(5)`
> 2. `fib(4) + fib(3)`
> 3. `(fib(3) + fib(2)) + (fib(2) + fib(1))`
> 4. `((fib(2) + fib(1)) + (fib(1) + fib(0))) + ((fib(1) + fib(0)) + fib(1))`
> 5. `(((fib(1) + fib(0)) + fib(1)) + (fib(1) + fib(0))) + ((fib(1) + fib(0)) + fib(1))`
> 
> 여기에서 세 번째 줄의 fib(2)가 중복되어 계산되고, 이것은 전체적인 계산 속도를 떨어뜨린다. 이 알고리즘의 시간 복잡도는 지수 함수가 된다.
> 
> 여기에서 각 함수의 계산값을 저장하는 객체 *m*을 추가하면, 이 알고리즘은 다음과 같이 바뀐다.
> 
> ```
> var m := map(0 → 1, 1 → 1)
> ```
> 
> ```
> function fib(n)
>  if n not in keys(m)
>   m[n] := fib(n-1) + fib(n-2)
>  return m[n]
> ```
> 
> 이렇게 각 계산값을 저장하면, 중복 계산이 줄어들고 시간 복잡도는 [O](https://ko.wikipedia.org/wiki/%EC%A0%90%EA%B7%BC_%ED%91%9C%EA%B8%B0%EB%B2%95)(n)이 된다.
> 

다이나믹 프로그래밍은 복잡한 문제를 간단한 복수의 문제로 나누어 푸는 문제해결 방식이다.

잘게 쪼갠 문제의 해를 저장하여 같은 하위 문제가 나와도 간단하게 해결하는것을 목표로 한다.

이 알고리즘으로 최단 경로 문제, 행렬의 제곱 문제 등의 최적화에서 사용된다.

## 그리디 알고리즘과 비교

다이나믹 프로그래밍은 항상 모든 해를 고려해야 한다는 단점이 있다. 이러한 단점을 극복하기 위해, 그리디 알고리즘을 사용한다.

그리디 알고리즘은 항상 최적해를 구해주진 않지만, 다이나믹 프로그래밍보다 빠르게 최적해에 근접한 해를 구할 수 있다. 길찾기 같은 순간순간 빠르게 판단해야 하는 문제에서 유용하다.

## 나의 풀이

```python
o = [1, 0]
for i in range(2, 82):
    if i % 2 == 0:
        o.append(o[i-1])
    else:
        o.append(o[i-2] + o[i-3])
        

n0, n1 = 0, 0
result = []
tc = int(input())
num = []

for i in range(tc):
    num.append(int(input()))

for i in num:
    print(o[i*2], o[i*2+1])
```
